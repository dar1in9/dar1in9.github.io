---
layout: post
title: 二叉树基本操作
category: 数据结构
tags: [数据结构]
---
## 二叉树基本操作

>CreateBitree()：建立二叉树。  
>Destroy(bitree *T)：销毁二叉树T。      
>ClearBitree(bitree *T)：将二叉树清空为空树。  
>BitreeDepth(bitree *T)：返回二叉树深度。    
>NodeCountBitree(bitree *T)：计算二叉树结点数。  
>LeafCountBitree(bitree *T) ：计算二叉树叶子个数。

## 二叉树的定义
```c
typedef int datatype;
typedef struct node
{
    datatype data;
    struct node *lchild, *rchild;
}bitree;
```
## 二叉树的建立
```c
bitree *Createtree()//递归
{
    char ch;
    bitree *T;
    scanf("%c",&ch);
    if(ch == '#')
        return NULL;
    else
    {
        T = (bitree *)malloc(sizeof(bitree));
        T->data = ch;
        T->lchild = Createbitree();
        T->rchild = Createbitree();
    }
    return T; 
}

bitree *Createbitree()//非递归
{
    char ch;
    bitree *Q[Max];
    int front, rear;
    bitree *root, *s;
    root = NULL;
    front = 1;
    rear = 0;
    while ((ch = getchar()) != '#')
    {
        s = NULL;
        if (ch !='@')
        {
            s = (bitree *)malloc(sizeof(bitree));
            s->data = ch;
            s->lchild = NULL;
            s->rchild = NULL;
        }
        rear++;

        Q[rear] = s;
        if(rear == 1)
            root = s;
        else
        {
            if (s && Q[front])
            {
                if(rear % 2 == 0)
                    Q[front]->lchild = s;
                else 
                    Q[front]->rchild = s;
            }
            if(rear % 2 == 1)
                front++;
        }
    }
    return root;
}
```

## 二叉树遍历

### **先序遍历**
```c
void PreOrder(bitree *T)
{
    if(T != NULL)
    {
        printf("%c",T->data);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}
```

### **中序遍历**
```c
void InOrder(bitree *T)
{
    if(T != NULL)
    {
        InOrder(T->lchild);
        printf("%c",T->data);
        InOrder(T->rchild);
    }
}
```

### **后序遍历**
```c
void PostOrder(bitree *T)
{
    if(T != NULL)
    {
        InOrder(T->lchild);
        InOrder(T->rchild);
        printf("%c",T->data);
    }
}
```
## 计算二叉树结点个数
```c
int NodeCountBitree(bitree *T) 
{
    
    if (!T) 
        return 0;
    return (NodeCountBitree(T->lchild) + NodeCountBitree(T->rchild) + 1);
}
```
**二叉树节点个数为左子节点个数 + 右子节点个数 + 1(根节点)**

## 计算[二叉树叶子](https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9/3620239?fr=aladdin)个数
```c
int LeafCountBitree(bitree *T) 
{
    if (!T->lchild && !T->rchild)
    {
        //printf("%c",T->data);//打印叶子
        return 1;
    }
    return (LeafCountBitree(T->lchild) + LeafCountBitree(T->rchild));
}
```
## 计算二叉树第k层节点个数
```c
int LevelNoteCount(bitree * T, int k)
{
    if (!T)
        return 0;
    if (k == 1)
        return 1;
    return LevelNoteCount(T->lchild, k - 1) + LevelNoteCount(T->rchild, k - 1);
}
```
 **二叉树第k层节点个数：如果二叉树为空，则二叉树叶子节点个数为 0，如果不为空，则二叉树第k层节点个数为左右子节点第k-1层节点个数之和。**int 
 ## 计算二叉树深度
 ```c
int BitreeDepth(bitree *T)
{
    if(T == NULL)
        return 0;
    int ldepth = BitreeDepth(T->lchild);
    int rdepth = BitreeDepth(T->rchild);
    return (ldepth>rchild) ? (ldepth + 1) : (rdepth + 1);
}
```
## 销毁二叉树
```c
int Destroy(bitree *T) //销毁二叉树
{
    if(!T) 
        return 0;
    Destroy(T->lchild);
    Destroy(T->rchild);
    free(T);
}
```