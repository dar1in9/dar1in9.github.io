---
layout: post
title: 二叉树基本操作
category: 数据结构
tags: [数据结构]
---
## 二叉树基本操作
>CreateBitree()：建立二叉树。  
>DestoryBitree(bitree *T)：销毁二叉树T。      
>ClearBitree(bitree *T)：将二叉树清空为空树。  
>BitreeDepth(bitree *T)：返回二叉树深度。  
>Root()：返回根。  
>NodeCountBitree(bitree *T)：计算二叉树结点数。  
>LeafCountBitree(Bitree *T) ：计算二叉树叶子个数。

## 二叉树的定义
```c
typedef int datatype;
typedef struct node
{
    datatype data;
    struct node *lchild, *rchild;
}bitree;
```
## 二叉树的建立
```c
bitree *Createtree()
{
    char ch;
    bitree *T;
    scanf("%c",&ch);
    if(ch == '#')
        return NULL;
    else
    {
        T = (bitree *)malloc(sizeof(bitree));
        T->data = ch;
        T->lchild = Createbitree();
        T->rchild = Createbitree();
    }
    return T; 
}
```

## 二叉树遍历

### **先序遍历**
```c
void PreOrder(bitree *T)
{
    if(T != NULL)
    {
        printf("%c",T->data);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}
```

### **中序遍历**
```c
void InOrder(bitree *T)
{
    if(T != NULL)
    {
        InOrder(T->lchild);
        printf("%c",T->data);
        InOrder(T->rchild);
    }
}
```

### **后序遍历**
```c
void PostOrder(bitree *T)
{
    if(T != NULL)
    {
        InOrder(T->lchild);
        InOrder(T->rchild);
        printf("%c",T->data);
    }
}
```
### 计算二叉树结点个数
```c
int NodeCountBitree(bitree *T) 
{
    
    if (!T) 
        return 0;
    return (NodeCountBitree(T->lchild) + NodeCountBitree(T->rchild) + 1);
}
```
**二叉树节点个数为左子节点个数 + 右子节点个数 + 1(根节点)**

### 计算[二叉树叶子个数](https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9/3620239?fr=aladdin)
```c
int LeafCountBitree(bitree *T) 
{
    if (!T) 
        return 0;
    if (!T->lchild && !T->rchild)
        return 1;
    return (LeafCountBitree(T->lchild) + LeafCountBitree(T->rchild));
}
```